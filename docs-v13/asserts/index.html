<!doctype html>
<title>
  
    Asserts | Node Tap
  
</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
html {
  display: block;
  font-family: sans-serif;
  padding: 0 1em;
  margin: 0 auto;
  border-top: 10px solid #f7df1e;
  line-height:1.5;
  color:#333;
  position:relative;
}

html::before {
  width:100%;
  display:block;
  position:fixed;
  top:0;
  left:0;
  height:10px;
  background:#f7df1e;
  content: " ";
}

body {
  padding:0;
  margin: 0;
}

a:hover, a:active, a:focus {
  color: red;
}

code, pre, kbd {
  font-size: 100%;
  font-family: Triplicate T4, Fira Mono OT, Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
}

section.side {
  display: block;
  padding:0;
  min-height:100px;
  margin: 0;
  width:100%;
}

.side h2, .side p {
  margin-top: 0;
}

section.side li {
  display: inline;
}

section.side ul {
  display: block;
  overflow:auto;
}

section.side li ul {
  display: inline;
}

.side ul {
  padding:0;
  margin:0 ;
}

.side img {
  display: block;
  margin-right: 1em;
  margin-top: 1em;
}

section.main {
  display: block;
  padding-top:20px;
}

@media only screen and (min-width: 240px) {
  .side img {
    float:left;
    margin: 0 1em 0 0;
  }
}

@media only screen and (min-width: 800px) {
  html {
    width:600px;
    padding:0 0 0 200px;
  }
  section.side {
    width: 180px;
    position: fixed;
    overflow:auto;
    max-height:100%;
    margin: 0 0 0 -200px;
  }
  .side img {
    display: block;
    float:none;
  }

  section.side ul {
    overflow: none;
    display: block;
  }

  section.side li {
    display: block;
  }

  section.side a {
    display: block;
  }

  section.side li ul {
    margin: 0;
    display: block;
  }

  section.side li li {
    margin-left: 1em;
  }

  .side h2, .side p {
    margin-top: 1em;
  }

  section.main {
    float: right;
    width: 600px;
    padding-bottom: 100px;
  }
}
</style>
<link href="../static/prism.css" rel="stylesheet">

<body>

<section class='side'>
  <h2><a href="../index.html"><img src='../static/tapjs.png' width=100 height=100 alt='Test Anything JS'></a></h2>
  <p>A Test-Anything-Protocol library for Node.js</p>
  <ul>
  
    <li>
      <a href="../index.html">Index</a>
      
    </li>
  
    <li>
      <a href="../basics/index.html">Getting Started</a>
      
    </li>
  
    <li>
      <a href="../using-with/index.html">Using tap with...</a>
      
    </li>
  
    <li>
      <a href="../configuring/index.html">Configuring tap</a>
      
    </li>
  
    <li>
      <a href="../api/index.html">API</a>
      
      <ul>
        
        <li><a href="index.html">Asserts</a></li>
        
        <li><a href="../promises/index.html">Promises</a></li>
        
        <li><a href="../subtests/index.html">Subtests</a></li>
        
        <li><a href="../parallel/index.html">Parallel Tests</a></li>
        
        <li><a href="../snapshots/index.html">Snapshot Testing</a></li>
        
        <li><a href="../test-lifecycle">Test Lifecycle Events</a></li>
        
        <li><a href="../grep/index.html">Filtering Tests: grep</a></li>
        
        <li><a href="../only/index.html">Filtering Tests: only</a></li>
        
        <li><a href="../mochalike/index.html">Mocha-like DSL</a></li>
        
        <li><a href="../advanced/index.html">Advanced</a></li>
        
      </ul>
      
    </li>
  
    <li>
      <a href="../cli/index.html">CLI</a>
      
    </li>
  
    <li>
      <a href="../coverage/index.html">Coverage</a>
      
    </li>
  
    <li>
      <a href="../coverage-map/index.html">Coverage Map</a>
      
    </li>
  
    <li>
      <a href="../save-failures-run-changed/index.html">Saving, Running Changed</a>
      
    </li>
  
    <li>
      <a href="../watch/index.html">Watching Files for Changes</a>
      
    </li>
  
    <li>
      <a href="../reporting/index.html">Reporting</a>
      
    </li>
  
    <li>
      <a href="../tap-format.1">The TAP Protocol</a>
      
    </li>
  
    <li>
      <a href="../tap-files/index.html">Working with TAP files</a>
      
    </li>
  
    <li>
      <a href="../changelog/index.html">Change Log</a>
      
    </li>
  
    <li>
      <a href="https://github.com/tapjs/node-tap">GitHub Repo</a>
      
    </li>
  
  </ul>
  <pre><a href="http://npm.im/tap">npm install tap</a>
<a href="../cli/index.html">tap test/*.js</a></pre>
</section>
<section class='main'>
<h1 id="asserts">Asserts</h1>

<p>The <code class="highlighter-rouge">Test</code> object has a collection of assertion methods, many of which
are given several synonyms for compatibility with other test runners
and the vagaries of human expectations and spelling.  When a synonym
is multi-word in <code class="highlighter-rouge">camelCase</code> the corresponding lower case and
<code class="highlighter-rouge">snake_case</code> versions are also created as synonyms.</p>

<p>All assertion methods take optional <code class="highlighter-rouge">message</code> and <code class="highlighter-rouge">extra</code> arguments as
the last two params.  The <code class="highlighter-rouge">message</code> is the name of the test.  The
<code class="highlighter-rouge">extra</code> argument can contain any arbitrary data about the test, but
the following fields are “special”.</p>

<ul>
  <li><code class="highlighter-rouge">todo</code> Set to boolean <code class="highlighter-rouge">true</code> or a String to mark this as pending</li>
  <li><code class="highlighter-rouge">skip</code> Set to boolean <code class="highlighter-rouge">true</code> or a String to mark this as skipped</li>
  <li><code class="highlighter-rouge">diagnostic</code> Set to boolean <code class="highlighter-rouge">true</code> to show a yaml diagnostic block
even if the test point passes.  (Failing asserts always show yaml
diagnostics.)</li>
  <li><code class="highlighter-rouge">at</code> Generated by the framework.  The location where the assertion
was called.  Do not set this field unless you know what you are
doing.</li>
  <li><code class="highlighter-rouge">stack</code> Generated by the framework.  The stack trace to the point
where the assertion was called.  Do not set this field unless you
know what you are doing.</li>
</ul>

<p><strong>Note</strong>: There’s no requirement that you use tap’s built-in
assertions.  You can also use any Error-throwing assertion library,
including Node.js’s built-in <code class="highlighter-rouge">assert</code> module.  A throw fails a test,
so not-throwing passes.  That does, however, mean that you won’t
generate a test point in your output for each assertion run.  You do
you.</p>

<h2 id="tokobj-message-extra">t.ok(obj, message, extra)</h2>

<p>Verifies that the object is truthy.</p>

<p>Synonyms: <code class="highlighter-rouge">t.true</code>, <code class="highlighter-rouge">t.assert</code></p>

<h2 id="tnotokobj-message-extra">t.notOk(obj, message, extra)</h2>

<p>Verifies that the object is not truthy.</p>

<p>Synonyms: <code class="highlighter-rouge">t.false</code>, <code class="highlighter-rouge">t.assertNot</code></p>

<h2 id="terrorobj-message-extra">t.error(obj, message, extra)</h2>

<p>If the object is an error, then the assertion fails.</p>

<p>Note: if an error is encountered unexpectedly, it’s often better to
simply throw it.  The Test object will handle this as a failure.</p>

<p>Synonyms: <code class="highlighter-rouge">t.ifErr</code>, <code class="highlighter-rouge">t.ifError</code></p>

<h2 id="temitseventemitter-event-message-extra">t.emits(eventEmitter, event, message, extra)</h2>

<p>Verify that the event emitter emits the named event before the end of
the test.</p>

<h2 id="trejectspromise--fn-expectederror-message-extra">t.rejects(promise | fn, [expectedError], message, extra)</h2>

<p>Verifies that the promise (or promise-returning function) rejects.  If
an expected error is provided, then also verify that the rejection
matches the expected error.</p>

<p>Note: since promises always reject and resolve asynchronously, this
assertion is implemented asynchronously.  As such, it does not return
a boolean to indicate its passing status.  Instead, it returns a
Promise that resolves when it is completed.</p>

<h2 id="tresolvespromise--fn-message-extra">t.resolves(promise | fn, message, extra)</h2>

<p>Verifies that the promise (or promise-returning function) resolves,
making no expectation about the value that the promise resolves to.</p>

<p>Note: since promises always reject and resolve asynchronously, this
assertion is implemented asynchronously.  As such, it does not return
a boolean to indicate its passing status.  Instead, it returns a
Promise that resolves when it is completed.</p>

<h2 id="tresolvematchpromise--fn-wanted-message-extra">t.resolveMatch(promise | fn, wanted, message, extra)</h2>

<p>Verifies that the promise (or promise-returning function) resolves,
and furthermore that the value of the promise matches the <code class="highlighter-rouge">wanted</code>
pattern using <code class="highlighter-rouge">t.match</code>.</p>

<p>Note: since promises always reject and resolve asynchronously, this
assertion is implemented asynchronously.  As such, it does not return
a boolean to indicate its passing status.  Instead, it returns a
Promise that resolves when it is completed.</p>

<h2 id="tresolvematchsnapshotpromise--fn-message-extra">t.resolveMatchSnapshot(promise | fn, message, extra)</h2>

<p>Verifies that the promise (or promise-returning function) resolves,
and furthermore that the value of the promise matches the snapshot.</p>

<p>Note: since promises always reject and resolve asynchronously, this
assertion is implemented asynchronously.  As such, it does not return
a boolean to indicate its passing status.  Instead, it returns a
Promise that resolves when it is completed.</p>

<h2 id="tthrowsfn-expectederror-message-extra">t.throws(fn, [expectedError], message, extra)</h2>

<p>Expect the function to throw an error.  If an expected error is
provided, then also verify that the thrown error matches the expected
error.</p>

<p>If the expected error is an object, then it’s matched against the
thrown error using <code class="highlighter-rouge">t.match(er, expectedError)</code>.  If it’s a function,
then the error is asserted to be a member of that class.</p>

<p>If the function has a name, and the message is not provided, then the
function name will be used as the message.</p>

<p>If the function is not provided, then this will be treated as a <code class="highlighter-rouge">todo</code>
test.</p>

<p>Caveat: if you pass a <code class="highlighter-rouge">extra</code> object to t.throws, then you MUST also
pass in an expected error, or else it will read the diag object as the
expected error, and get upset when your thrown error doesn’t match
<code class="highlighter-rouge">{skip:true}</code> or whatever.</p>

<p>For example, this will not work as expected:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// anti-example, do not use!</span>
<span class="nx">t</span><span class="p">.</span><span class="kr">throws</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'x'</span><span class="p">)},</span> <span class="p">{</span> <span class="na">skip</span><span class="p">:</span> <span class="kc">true</span> <span class="p">})</span>
</code></pre></div></div>

<p>But this is fine:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// this example is ok to use.</span>
<span class="c1">// note the empty 'expected error' object.</span>
<span class="c1">// since it has no fields, it'll only verify that the thrown thing is</span>
<span class="c1">// an object, not the value of any properties</span>
<span class="nx">t</span><span class="p">.</span><span class="kr">throws</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'x'</span><span class="p">)},</span> <span class="p">{},</span> <span class="p">{</span> <span class="na">skip</span><span class="p">:</span> <span class="kc">true</span> <span class="p">})</span>
</code></pre></div></div>

<p>The expected error is tested against the throw error using <code class="highlighter-rouge">t.match</code>,
so regular expressions and the like are fine.  If the expected error
is an <code class="highlighter-rouge">Error</code> object, then the <code class="highlighter-rouge">stack</code> field is ignored, since that
will generally never match.</p>

<p>Synonyms: <code class="highlighter-rouge">t.throw</code></p>

<h2 id="tdoesnotthrowfn-message-extra">t.doesNotThrow(fn, message, extra)</h2>

<p>Verify that the provided function does not throw.</p>

<p>If the function has a name, and the message is not provided, then the
function name will be used as the message.</p>

<p>If the function is not provided, then this will be treated as a <code class="highlighter-rouge">todo</code>
test.</p>

<p>Note: if an error is encountered unexpectedly, it’s often better to
simply throw it.  The Test object will handle this as a failure.</p>

<p>Synonyms: <code class="highlighter-rouge">t.notThrow</code></p>

<h2 id="texpectuncaughtexceptionfn-expectederror-message-extra">t.expectUncaughtException(fn, [expectedError], message, extra)</h2>

<p>Expect the function to throw an uncaught exception at some point in the
future, before the test ends.  If the test ends without having thrown the
expected error, then the test fails.</p>

<p>This is useful for verifying that an error thrown in some part of your code
will <em>not</em> be handled, which would normally result in a program crash, and
verify behavior in those scenarios.  If the error is thrown synchronously,
or within a promise, then the <code class="highlighter-rouge">t.throws()</code> or <code class="highlighter-rouge">t.rejects()</code> methods are
more appropriate.</p>

<p>If called multiple times, then the uncaught exception errors must be
emitted in the order called.</p>

<p><strong>Note</strong>: This method will <em>not</em> properly link a thrown error to the
correct test object in some cases involving native modules on Node version
8, because the <code class="highlighter-rouge">async_hooks</code> module does not track the execution context ID
across native boundaries.</p>

<h2 id="tequalfound-wanted-message-extra">t.equal(found, wanted, message, extra)</h2>

<p>Verify that the object found is exactly the same (that is, <code class="highlighter-rouge">===</code>) to
the object that is wanted.</p>

<p>Synonyms: <code class="highlighter-rouge">t.equals</code>, <code class="highlighter-rouge">t.isEqual</code>, <code class="highlighter-rouge">t.is</code>, <code class="highlighter-rouge">t.strictEqual</code>,
<code class="highlighter-rouge">t.strictEquals</code>, <code class="highlighter-rouge">t.strictIs</code>, <code class="highlighter-rouge">t.isStrict</code>, <code class="highlighter-rouge">t.isStrictly</code></p>

<h2 id="tnotequalfound-notwanted-message-extra">t.notEqual(found, notWanted, message, extra)</h2>

<p>Inverse of <code class="highlighter-rouge">t.equal()</code>.</p>

<p>Verify that the object found is not exactly the same (that is, <code class="highlighter-rouge">!==</code>) as
the object that is wanted.</p>

<p>Synonyms: <code class="highlighter-rouge">t.inequal</code>, <code class="highlighter-rouge">t.notEqual</code>, <code class="highlighter-rouge">t.notEquals</code>,
<code class="highlighter-rouge">t.notStrictEqual</code>, <code class="highlighter-rouge">t.notStrictEquals</code>, <code class="highlighter-rouge">t.isNotEqual</code>, <code class="highlighter-rouge">t.isNot</code>,
<code class="highlighter-rouge">t.doesNotEqual</code>, <code class="highlighter-rouge">t.isInequal</code></p>

<h2 id="tsamefound-wanted-message-extra">t.same(found, wanted, message, extra)</h2>

<p>Verify that the found object is deeply equivalent to the wanted
object.  Use non-strict equality for scalars (ie, <code class="highlighter-rouge">==</code>).  See:
<a href="http://npm.im/tcompare">tcompare</a></p>

<p>Synonyms: <code class="highlighter-rouge">t.equivalent</code>, <code class="highlighter-rouge">t.looseEqual</code>, <code class="highlighter-rouge">t.looseEquals</code>,
<code class="highlighter-rouge">t.deepEqual</code>, <code class="highlighter-rouge">t.deepEquals</code>, <code class="highlighter-rouge">t.isLoose</code>, <code class="highlighter-rouge">t.looseIs</code></p>

<h2 id="tnotsamefound-notwanted-message-extra">t.notSame(found, notWanted, message, extra)</h2>

<p>Inverse of <code class="highlighter-rouge">t.same()</code>.</p>

<p>Verify that the found object is not deeply equivalent to the
unwanted object.  Uses non-strict inequality (ie, <code class="highlighter-rouge">!=</code>) for scalars.</p>

<p>Synonyms: <code class="highlighter-rouge">t.inequivalent</code>, <code class="highlighter-rouge">t.looseInequal</code>, <code class="highlighter-rouge">t.notDeep</code>,
<code class="highlighter-rouge">t.deepInequal</code>, <code class="highlighter-rouge">t.notLoose</code>, <code class="highlighter-rouge">t.looseNot</code></p>

<h2 id="tstrictsamefound-wanted-message-extra">t.strictSame(found, wanted, message, extra)</h2>

<p>Strict version of <code class="highlighter-rouge">t.same()</code>.</p>

<p>Verify that the found object is deeply equivalent to the wanted
object.  Use strict equality for scalars (ie, <code class="highlighter-rouge">===</code>).</p>

<p>Synonyms: <code class="highlighter-rouge">t.strictEquivalent</code>, <code class="highlighter-rouge">t.strictDeepEqual</code>, <code class="highlighter-rouge">t.sameStrict</code>,
<code class="highlighter-rouge">t.deepIs</code>, <code class="highlighter-rouge">t.isDeeply</code>, <code class="highlighter-rouge">t.isDeep</code>, <code class="highlighter-rouge">t.strictDeepEquals</code></p>

<h2 id="tstrictnotsamefound-notwanted-message-extra">t.strictNotSame(found, notWanted, message, extra)</h2>

<p>Inverse of <code class="highlighter-rouge">t.strictSame()</code>.</p>

<p>Verify that the found object is not deeply equivalent to the unwanted
object.  Use strict equality for scalars (ie, <code class="highlighter-rouge">===</code>).</p>

<p>Synonyms: <code class="highlighter-rouge">t.strictInequivalent</code>, <code class="highlighter-rouge">t.strictDeepInequal</code>,
<code class="highlighter-rouge">t.notSameStrict</code>, <code class="highlighter-rouge">t.deepNot</code>, <code class="highlighter-rouge">t.notDeeply</code>, <code class="highlighter-rouge">t.strictDeepInequals</code>,
<code class="highlighter-rouge">t.notStrictSame</code></p>

<h2 id="tmatchfound-pattern-message-extra">t.match(found, pattern, message, extra)</h2>

<p>Verify that the found object matches the pattern provided.</p>

<p>If pattern is a regular expression, and found is a string, then verify
that the string matches the pattern.</p>

<p>If the pattern is a string, and found is a string, then verify that
the pattern occurs within the string somewhere.</p>

<p>If pattern is an object, then verify that all of the (enumerable)
fields in the pattern match the corresponding fields in the object
using this same algorithm.  For example, the pattern <code class="highlighter-rouge">{x:/a[sdf]{3}/}</code>
would successfully match <code class="highlighter-rouge">{x:'asdf',y:'z'}</code>.</p>

<p>This is useful when you want to verify that an object has a certain
set of required fields, but additional fields are ok.</p>

<p>See <a href="http://npm.im/tcompare">tcompare</a> for the full details on how this
works.</p>

<p>Synonyms: <code class="highlighter-rouge">t.has</code>, <code class="highlighter-rouge">t.hasFields</code>, <code class="highlighter-rouge">t.matches</code>, <code class="highlighter-rouge">t.similar</code>, <code class="highlighter-rouge">t.like</code>,
<code class="highlighter-rouge">t.isLike</code>, <code class="highlighter-rouge">t.includes</code>, <code class="highlighter-rouge">t.include</code>, <code class="highlighter-rouge">t.contains</code></p>

<h2 id="tnotmatchfound-pattern-message-extra">t.notMatch(found, pattern, message, extra)</h2>

<p>Inverse of <code class="highlighter-rouge">match()</code></p>

<p>Verify that the found object does not match the pattern provided.</p>

<p>Synonyms: <code class="highlighter-rouge">t.dissimilar</code>, <code class="highlighter-rouge">t.unsimilar</code>, <code class="highlighter-rouge">t.notSimilar</code>, <code class="highlighter-rouge">t.unlike</code>,
<code class="highlighter-rouge">t.isUnlike</code>, <code class="highlighter-rouge">t.notLike</code>, <code class="highlighter-rouge">t.isNotLike</code>, <code class="highlighter-rouge">t.doesNotHave</code>,
<code class="highlighter-rouge">t.isNotSimilar</code>, <code class="highlighter-rouge">t.isDissimilar</code></p>

<h2 id="ttypeobject-type-message-extra">t.type(object, type, message, extra)</h2>

<p>Verify that the object is of the type provided.</p>

<p>Type can be a string that matches the <code class="highlighter-rouge">typeof</code> value of the object, or
the string name of any constructor in the object’s prototype chain, or
a constructor function in the object’s prototype chain.</p>

<p>For example, all the following will pass:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">t</span><span class="p">.</span><span class="nx">type</span><span class="p">(</span><span class="k">new</span> <span class="nb">Date</span><span class="p">(),</span> <span class="s1">'object'</span><span class="p">)</span>
<span class="nx">t</span><span class="p">.</span><span class="nx">type</span><span class="p">(</span><span class="k">new</span> <span class="nb">Date</span><span class="p">(),</span> <span class="s1">'Date'</span><span class="p">)</span>
<span class="nx">t</span><span class="p">.</span><span class="nx">type</span><span class="p">(</span><span class="k">new</span> <span class="nb">Date</span><span class="p">(),</span> <span class="nb">Date</span><span class="p">)</span>
</code></pre></div></div>

<p>Synonyms: <code class="highlighter-rouge">t.isa</code>, <code class="highlighter-rouge">t.isA</code></p>

</section>
<script src="../static/prism.js"></script>
</body>
